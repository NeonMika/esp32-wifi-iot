<html>

<head>
	<meta name=”robots” content=”noindex”>
	<meta charset="UTF-8">
	<title>Home Automation</title>
	<script src="https://unpkg.com/vue@next"></script>
	<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
	<!--<script src="https://cdn.plot.ly/plotly-2.8.3.min.js"></script>-->
	<script src="https://cdn.plot.ly/plotly-2.2.0.min.js"></script>
	<script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
	<div id="app">
		<h1>Home Automation</h1>
		<h3>Temparature</h3>
		<form>
			<span> From </span>
			<input name="temp-date-from" type="date" id="temp-date-from" v-model="temp_date_from">
			<input name="temp-time-from" type="time" id="temp-time-from" v-model="temp_time_from">
			<span> to </span>
			<input name="temp-date-to" type="date" id="temp-date-to" v-model="temp_date_to">
			<input name="temp-time-to" type="time" id="temp-time-to" v-model="temp_time_to">
		</form>
		<div id="temp-charts" v-html="temp_charts_html"></div>
		<div id="temp-chart" v-html="temp_chart_html"></div>
		<pre>{{ !is_loading ? JSON.stringify(filtered_temps, null, 2) : '... loading data from server ...'}}</pre>
	</div>
	<script type="module">
		import * as Plot from "https://cdn.skypack.dev/@observablehq/plot@0.4";

		const now = new Date()

		const today = d3.utcFormat("%Y-%m-%d")(now)
		const now_hour_minutes = d3.utcFormat("%H:%M")(now)

		const yesterday = d3.utcFormat("%Y-%m-%d")(new Date(now.getTime() - 1000 * 60 * 60 * 24))

		const VuePage = {
			data() {
				return {
					temp_date_from: yesterday,
					temp_time_from: now_hour_minutes,
					temp_date_to: today,
					temp_time_to: now_hour_minutes,

					is_loading: false,
					temps: [],

					is_rendering: false,
					repeat_render: false,
					temp_charts_html: null,
					temp_chart_html: null,

					d3: Object.freeze(d3),
				}
			},
			computed: {
				temp_from: function () {
					return new Date(this.temp_date_from + "T" + this.temp_time_from)
				},
				temp_to: function () {
					return new Date(this.temp_date_to + "T" + this.temp_time_to)
				},
				filtered_temps: function () {
					if (this.temps) {
						const t_start = new Date().getTime()
						const filtered = this.temps.filter(d => d.timestamp >= this.temp_from && d.timestamp <= this.temp_to)
						const t_end = new Date().getTime()
						console.log(`Filtering took ${t_end - t_start}ms`)
						return filtered
					}
					return []
				}
			},
			watch: {
				filtered_temps: async function () {
					await this.plotTemperatures()
				}
			},
			methods: {
				plotTemperatures: async function () {
					console.log("plot call")
					if (this.is_rendering) {
						this.repeat_render = true
					}
					console.log("plot enter")

					do {
						console.log("plot repeat")
						this.is_rendering = true
						this.repeat_render = false

						const data = this.filtered_temps;
						await this.plotCharts(data)
						await this.plotChart(data)
					} while (this.repeat_renders)
					this.is_rendering = false
				},
				plotCharts: async function (data) {
					const div = document.getElementById('temp-charts')

					const first_date = d3.min(data.map(x => x.timestamp))
					const last_date = d3.max(data.map(x => x.timestamp))

					if (!first_date) {
						this.temp_charts_html = ""
						return
					}

					const seconds_range = (last_date.getTime() - first_date.getTime()) / 1000
					const minutes_range = seconds_range / 60

					const BIN_WIDTH = 15
					const n_bins = Math.round(minutes_range / BIN_WIDTH)

					if (data.length > 0) {
						const t_start = new Date().getTime()

						await new Promise(resolve => {
							this.temp_charts_html = Plot.plot({
								width: div.clientWidth,
								color: {
									type: "categorical",
									scheme: "pastel1",
									// legend: "ramp",
									legend: true
								},
								x: { type: "utc", tickRotate: -30, ticks: 12, nice: true },
								y: { type: "linear", nice: true },
								facet: { data: data, x: "mac_address" },
								grid: true,
								marks: [
									Plot.frame(),
									Plot.areaY(
										data,
										Plot.binX(
											{ y1: "min", y2: "max", filter: null },
											{ x: "timestamp", thresholds: n_bins, y: "temp", fillOpacity: 0.2, inset: 0, }
										)
									),
									Plot.line(
										data,
										Plot.binX(
											{ y: "mean", filter: null },
											{ x: "timestamp", thresholds: n_bins, y: "temp", stroke: "sensor_id", strokeWidth: 1.5, inset: 0, }
										)
									),
									Plot.line(
										data,
										Plot.binX(
											{ y: "mean", filter: null },
											{ x: "timestamp", thresholds: n_bins, y: "temp", stroke: "black", strokeWidth: 1.5, inset: 0, }
										)
									),
									//Plot.line(data,  Plot.groupX({ y: data => (data.length == 1 && !data[0]) ? undefined : data.reduce((a,b) => a + b, 0) / data.length }, { x: d => new Date(d.timestamp.getTime()).setSeconds(0, 0), y: "temp", stroke: "black", strokeWidth: 7.5, curve: "natural" }))
								],
							}).outerHTML

							const t_end = new Date().getTime()
							console.log(`Plotting took ${t_end - t_start}ms for ${data.length} data points`)

							resolve()
						});
					}
				},
				plotChart: async function (data) {
					const div = document.getElementById('temp-chart')

					const first_date = d3.min(data.map(x => x.timestamp))
					const last_date = d3.max(data.map(x => x.timestamp))

					if (!first_date) {
						this.temp_chart_html = ""
						return
					}

					const seconds_range = (last_date.getTime() - first_date.getTime()) / 1000
					const minutes_range = seconds_range / 60

					const BIN_WIDTH = 15
					const n_bins = Math.round(minutes_range / BIN_WIDTH)

					if (data.length > 0) {
						const t_start = new Date().getTime()

						await new Promise(resolve => {
							this.temp_chart_html = Plot.plot({
								width: div.clientWidth,
								color: {
									type: "categorical",
									// scheme: "pastel1",
									// legend: "ramp",
									legend: true
								},
								x: { type: "utc", tickRotate: -30, ticks: 12, nice: true },
								y: { type: "linear", nice: true },
								grid: true,
								marks: [
									Plot.frame(),
									Plot.line(
										data,
										Plot.binX(
											{ y: "mean", filter: null },
											{ x: "timestamp", thresholds: n_bins, y: "temp", stroke: "mac_address", strokeWidth: 2.5, inset: 0, }
										)
									)
								],
							}).outerHTML

							const t_end = new Date().getTime()
							console.log(`Plotting took ${t_end - t_start}ms for ${data.length} data points`)

							resolve()
						});
					}
				},
				reload: async function () {
					const device_numbers = {}
					let i = 1;
					console.log("... loading data ...")
					let t_start = new Date().getTime()
					this.is_loading = true
					this.temps = (await axios.get("/api/sensors/temp/5mins")).data.map(t => {
						if (!device_numbers[t.mac_address]) {
							device_numbers[t.mac_address] = i
							i++
						}

						const ensureTwoDigit = n => (n > 9 ? "" : "0") + n;

						const device_nr = device_numbers[t.mac_address]
						const sensor_id = `Device ${device_nr}, sensor ${t.sensor_nr}`
						const time_string = t._id.day_and_hour + ":" + ensureTwoDigit(t._id.five_min_slot * 5) + ":00Z"

						return {
							timestamp: new Date(time_string),
							temp: +t.avg_temp,
							sensor_nr: +t.sensor_nr,
							mac_address: t.mac_address,
							device_nr: device_nr,
							sensor_id: sensor_id
						};
					});
					let t_end = new Date().getTime()
					console.log(`Loading took ${t_end - t_start}ms for ${this.temps.length} data points`)

					console.log("... sorting data ...")
					t_start = new Date().getTime()
					function compare(a, b) {
						if (a.timestamp < b.timestamp) {
							return -1;
						}
						if (a.timestamp > b.timestamp) {
							return 1;
						}
						return 0;
					}
					this.temps.sort(compare)
					t_end = new Date().getTime()
					console.log(`Sorting took ${t_end - t_start}ms`)
					this.is_loading = false
				}
			},
			async mounted() {
				this.reload();
			}
		}

		Vue.createApp(VuePage).mount('#app')
	</script>
</body>

</html>